local game_state = require "multiplayer.game.game_state"

function init(self)
	msg.post('.', 'acquire_input_focus')
	msg.post("multiplayer", "register")

	self.players = {}
	self.player_node = {}

	self.game_state = game_state.create()
end

local function start_state_broadcast(self)
	local broadcast_frequency = 0.2
	self.broadcast_handle = timer.delay(broadcast_frequency, true, function()
		for player_ip, _ in pairs(self.players) do
			local node_id = self.player_node[player_ip]
			self.players[player_ip].position = go.get_position(node_id)
			-- local player_json = json.encode(self.players[player_ip])
		end
		-- msg.post("multiplayer", "server_broadcast", { data = json.encode(self.players) })
		print(json.encode(self.game_state.current_state()))
	end)
end

local function stop_state_broadcast(self)
	timer.cancel(self.broadcast_handle)
	self.broadcast_handle = nil
end

function on_message(self, message_id, message)
	if message_id == hash("start_server") then
		msg.post("multiplayer", "start_server")
		local game_scene = factory.create("factory#factory", vmath.vector3(568, 320, 0))
		self.game_scene = game_scene
		msg.post(self.game_scene, "set_server")
		start_state_broadcast(self)

	elseif message_id == hash("stop_server") then
		msg.post("multiplayer", "stop_server")
		stop_state_broadcast(self)
		if self.game_scene then
			go.delete(self.game_scene)
		end

	elseif message_id == hash("create_player") then
		if self.game_scene then
			msg.post(self.game_scene, "create_player", { ip = message.ip })
		end

	elseif message_id == hash("remove_player") then
		if self.game_scene then
			msg.post(self.game_scene, "remove_player", { ip = message.ip })
		end

	elseif message_id == hash("server_tcp_data") then
		local ok, data = pcall(json.decode, message.data)
		if ok then
			msg.post(self.game_scene, "move_player", { player = message.from, data = data })
		end
	end
end
