local tcp_server = require "defnet.tcp_server"
local tcp_client = require "defnet.tcp_client"

local p2p_discovery = require "defnet.p2p_discovery"

local DISCOVERY_PORT = 50000
local SERVER_PORT = 6969

local function post_to_sender(self, message_id, data)
	msg.post(self.post_address, message_id, data)
end

local function log(self, message)
	if self.post_address then
		msg.post(self.post_address, "log", {data = message})
	end
end

function init(self)
	self.p2p = p2p_discovery.create(DISCOVERY_PORT)

	self.create_server = function ()
		self.clients = {}
		log(self, "[multiplayer] creating tcp server")
		self.server= tcp_server.create(SERVER_PORT,
			function(data, ip, port, client)
				-- log(self, "TCP server received data \n'" .. data .. "'\nfrom " .. ip .. ":" .. port)
				local ok, data = pcall(json.decode, data)
				if ok then
					-- print(dump(data))
					post_to_sender(self, "analog", {type = "analog", from = ip, data = data})
				end
			end,
			function(ip, port, client)
				log(self, "Client connected from " .. ip .. ":" .. port)
				post_to_sender(self, "create_player", {ip = ip})
				table.insert(self.clients, client)
			end,
			function (ip, port, client)
				log(self, "Client discconnected from " .. ip .. ":" .. port)
				post_to_sender(self, "remove_player", {ip = ip})
				for i = 1, #self.clients do
					if self.clients[i] == client then
						table.remove(self.clients, i)
					end
				end
			end)
		self.server.start()
		log(self, "[multiplayer] tcp server started")
		self.p2p.broadcast("findme")
	end

	self.find_servers = function()
		self.available_servers = {}
		self.p2p.listen("findme", function(ip, port, message)
			if self.available_servers[ip] == nil then
				self.available_servers[ip] = os.time()
				post_to_sender(self, "ip_discovery", { servers = self.available_servers} )
			end
			self.available_servers[ip] = os.time()
		end)
		self.listening = true
	end

	self.connect = function(ip)
		local client, err = tcp_client.create(ip, SERVER_PORT,
			function(data)
				log(self, data)
				log(self, "TCP client received data \n'" .. data .. "'")
			end,
			function()
				log(self, "Disconnected")
				self.client = nil
			end)
		if client then
			log(self, "Connected to " .. ip)
			self.client = client
		else
			log(self, "Could not connect" .. err)
		end
	end

end

function final(self)
	print("stopping multiplayer")
	self.p2p.stop()
	if self.server then
		self.server.stop()
	end
	if self.client then
		self.client.destroy()
	end
end

function update(self, dt)
	self.p2p.update()
	if self.server then
		self.server.update()
	end
	if self.client then
		self.client.update()
	end
	if self.listening then
		local max_seconds = 2
		local changed = false
		for ip, updated_at in pairs(self.available_servers) do
			if os.time() - updated_at >= max_seconds then
				self.available_servers[ip] = nil
				changed = true
			end
		end
		if changed then
			print("[UPDATE]")
			for ip, updated_at in pairs(self.available_servers) do
				print(ip, updated_at)
			end
			post_to_sender(self, "ip_discovery", { servers = self.available_servers })
		end
	end
end

---@param message_string string
local function rate_limited_send(self, message_string)
	local max_diff = 0.01
	local diff = max_diff
	if self.last_sent_time == nil then
		self.last_sent_time = os.clock()
	else
		local now = os.clock()
		diff = now - self.last_sent_time
		if diff >= max_diff then
			self.last_sent_time = now
			self.client.send(string.gsub(message_string .. '\n', "\n\n", "\n"))
		end
	end
end

local function handle_send_to_server(self, message)
	local json_data = json.encode(message.data)
	local formatted_string = string.gsub(json_data .. '\n', "\n\n", "\n")
	
	local is_analog_end = message.type == "analog" and message.data.x == 0 and message.data.y == 0
	if is_analog_end then
		self.client.send(formatted_string)
	else
		rate_limited_send(self, formatted_string)
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("register") then
		self.post_address = sender
		print("register mp")
	elseif message_id == hash("start_server") then
		self.create_server()
	elseif message_id == hash("server_broadcast") then
		if self.server then
			self.server.broadcast(string.gsub(message.data .. '\n', "\n\n", "\n"))
		end
	elseif message_id == hash("stop_server") then
		self.p2p.stop()
		if self.server then
			self.server.stop()
		end
	elseif message_id == hash("find_servers") then
		self.find_servers()
	elseif message_id == hash("stop_discovery") then
		self.listening = false
		self.p2p.stop()
	elseif message_id == hash("connect") then
		self.connect(message.ip)
	elseif message_id == hash("send_to_server") then
		handle_send_to_server(self, message)
	end
end

function dump(o)
   if type(o) == 'table' then
      local s = '{ '
      for k,v in pairs(o) do
         if type(k) ~= 'number' then k = '"'..k..'"' end
         s = s .. '['..k..'] = ' .. dump(v) .. ','
      end
      return s .. '} '
   else
      return tostring(o)
   end
end