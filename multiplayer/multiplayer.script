local tcp_server = require "defnet.tcp_server"
local tcp_client = require "defnet.tcp_client"

local p2p_discovery = require "defnet.p2p_discovery"

local DISCOVERY_PORT = 50000
local SERVER_PORT = 6969

local sender_address = nil
local function post_to_sender(message_id, data)
	if sender_address then
		msg.post(sender_address, message_id, data)
	end
end

local function log(message)
	print("[MULTIPLAYER]", message)
	post_to_sender("log", { data = message })
end

local function create_server(self)
	self.tcp_clients = {}
	log("Creating TCP server")
	self.tcp_server = tcp_server.create(SERVER_PORT,
		function(data, ip, port, client)
			post_to_sender("server_tcp_data", { from = ip, data = data })
		end,
		function(ip, port, client)
			log("Client connected from " .. ip .. ":" .. port)
			self.tcp_clients[ip] = client
			post_to_sender("create_player", { ip = ip })
			table.insert(self.tcp_clients, client)
		end,
		function(ip, port, client)
			print("Client disconnected:", ip, port)
			if ip == nil then
				return
			end
			post_to_sender("remove_player", { ip = ip })
			for i = 1, #self.tcp_clients do
				if self.tcp_clients[i] == client then
					table.remove(self.tcp_clients, i)
				end
			end
		end)
	self.tcp_server.start()
	log("TCP server started")
	self.p2p.broadcast("findme")
end

local function find_servers(self)
	self.available_servers = {}
	self.p2p.listen("findme", function(ip, port, message)
		if self.available_servers[ip] == nil then
			self.available_servers[ip] = os.time()
			post_to_sender("ip_discovery", { servers = self.available_servers })
		end
		self.available_servers[ip] = os.time()
	end)
	self.p2p_listening = true
end

local function connect_to_server(self, ip)
	local client, err = tcp_client.create(ip, SERVER_PORT,
		function(data)
			post_to_sender("received_from_server", { data = data })
		end,
		function()
			post_to_sender("disconnected")
			self.tcp_client = nil
		end)
	if client then
		log("Connected to " .. ip)
		self.tcp_client = client
	else
		log("Could not connect" .. err)
	end
end

function init(self)
	self.p2p = p2p_discovery.create(DISCOVERY_PORT)
end

function final(self)
	print("stopping multiplayer")
	self.p2p.stop()
	if self.tcp_server then
		self.tcp_server.stop()
	end
	if self.tcp_client then
		self.tcp_client.destroy()
	end
end

function update(self, dt)
	self.p2p.update()
	if self.tcp_server then
		self.tcp_server.update()
	end
	if self.tcp_client then
		self.tcp_client.update()
	end
	if self.p2p_listening then
		local max_seconds = 2
		local changed = false
		for ip, updated_at in pairs(self.available_servers) do
			if os.time() - updated_at >= max_seconds then
				self.available_servers[ip] = nil
				changed = true
			end
		end
		if changed then
			local message = "[UPDATE] "
			for ip, updated_at in pairs(self.available_servers) do
				message = message .. ip .. ", "
			end
			print(message)
			post_to_sender("ip_discovery", { servers = self.available_servers })
		end
	end
end

local function packet_string(s)
	return string.gsub(s .. "\n", "\n\n", "\n")
end

---@param message_string string
local function rate_limited_send(self, message_string)
	local max_diff = 0.01
	local diff = max_diff
	if self.last_sent_time == nil then
		self.last_sent_time = os.clock()
	else
		local now = os.clock()
		diff = now - self.last_sent_time
		if diff >= max_diff then
			self.last_sent_time = now
			self.tcp_client.send(packet_string(message_string))
		end
	end
end

local function send_to_server(self, message)
	local json_data = json.encode(message.data)
	local packet = packet_string(json_data)

	local is_analog_end = message.type == "analog" and message.data.x == 0 and message.data.y == 0
	if is_analog_end then
		self.tcp_client.send(packet)
	else
		rate_limited_send(self, packet)
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("register") then
		sender_address = sender
	elseif message_id == hash("start_server") then
		create_server(self)
	elseif message_id == hash("server_broadcast") then
		if self.tcp_server then
			self.tcp_server.broadcast(packet_string(message.data))
		end
	elseif message_id == hash("server_send_to_client") then
		self.tcp_server.broadcast(packet_string(message.data))
		if self.tcp_clients[message.ip] then
			self.tcp_server.send(packet_string(message.data), self.tcp_clients[message.ip])
		end
	elseif message_id == hash("stop_server") then
		self.p2p.stop()
		if self.tcp_server then
			self.tcp_server.stop()
		end
	elseif message_id == hash("find_servers") then
		find_servers(self)
	elseif message_id == hash("stop_discovery") then
		self.p2p_listening = false
		self.p2p.stop()
	elseif message_id == hash("connect") then
		connect_to_server(self, message.ip)
	elseif message_id == hash("send_to_server") then
		send_to_server(self, message)
	end
end
